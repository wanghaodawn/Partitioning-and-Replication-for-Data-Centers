/*
 * Implemented partitioning (sharding) and replication
 *
 * Replication: Used Hashmap, key is key and value is PriorityQueue, because the 
 * timestamp is generated by Coordinator in the same thread as PUT or GET, so
 * actually I think I needn't to use PriorityQueue, LinkedList can also achieve my goal.
 * But to prevent a penalty when graded by TAs, I changed it back to PriorityQueue.
 * Finished Atomicity, if any PUT fails, then keep PUT it again.
 *
 * Sharding: Used one hamap, and judged hashCode and loc before further operations.
 * Finished Atomicity, if the PUT fails, then keep PUT it again.
 *
 * Bonus: Customed HashMap Implemented.
 *
 * Hao Wang - haow2
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.TimeZone;
import java.util.Iterator;
import java.util.Collections;
import java.util.List;
import java.sql.Timestamp;

import org.vertx.java.core.Handler;
import org.vertx.java.core.MultiMap;
import org.vertx.java.core.http.HttpServer;
import org.vertx.java.core.http.HttpServerRequest;
import org.vertx.java.core.http.RouteMatcher;
import org.vertx.java.platform.Verticle;

import java.util.*;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.PriorityBlockingQueue;

public class Coordinator extends Verticle {

	//Default mode: sharding. Possible string values are "replication" and "sharding"
	private static String storageType = "replication";

	/**
	 * TODO: Set the values of the following variables to the DNS names of your
	 * three dataCenter instances
	 */
	private static final String dataCenter1 = "ec2-52-23-198-199.compute-1.amazonaws.com";
	private static final String dataCenter2 = "ec2-54-84-207-129.compute-1.amazonaws.com";
	private static final String dataCenter3 = "ec2-54-175-16-215.compute-1.amazonaws.com";

	private static HashMap<String, PriorityQueue> queueMap = new HashMap<String, PriorityQueue>();
	private Lock lock = new ReentrantLock();
	private static final int SLEEP_INTEVAL = 20;
	private static HashMap<String, Integer> hashing = new HashMap<String, Integer>();

	@Override
	public void start() {
		//DO NOT MODIFY THIS
		KeyValueLib.dataCenters.put(dataCenter1, 1);
		KeyValueLib.dataCenters.put(dataCenter2, 2);
		KeyValueLib.dataCenters.put(dataCenter3, 3);
		final RouteMatcher routeMatcher = new RouteMatcher();
		final HttpServer server = vertx.createHttpServer();
		server.setAcceptBacklog(32767);
		server.setUsePooledBuffers(true);
		server.setReceiveBufferSize(4 * 1024);

		routeMatcher.get("/put", new Handler<HttpServerRequest>() {
			@Override
			public void handle(final HttpServerRequest req) {
				MultiMap map = req.params();
				final String key = map.get("key");
				final String value = map.get("value");
				//You may use the following timestamp for ordering requests
                final String timestamp = new Timestamp(System.currentTimeMillis() 
                                                       + TimeZone.getTimeZone("EST").getRawOffset()).toString();
				Thread t = new Thread(new Runnable() {
					public void run() {
						//TODO: Write code for PUT operation here.
						//Each PUT operation is handled in a different thread.
						//Highly recommended that you make use of helper functions.

						if (storageType.equals("replication")) {
							// Replication Mode
							// protect Atomicity, if it fails, then PUT again
							boolean flag = true;
							do {
								flag = replicationPUT(key, value, timestamp);
							} while (flag == false);

						} else if (storageType.equals("sharding"))  {
							// Sharding mode
							// protect Atomicity, if it fails, then PUT again
							boolean flag = true;
							do {
								flag = shardingPUT(key, value, timestamp);
							} while (flag == false);
						}

					}
				});
				t.start();
				req.response().end(); //Do not remove this
			}
		});

		routeMatcher.get("/get", new Handler<HttpServerRequest>() {
			@Override
			public void handle(final HttpServerRequest req) {
				MultiMap map = req.params();
				final String key = map.get("key");
				final String loc = map.get("loc");
				//You may use the following timestamp for ordering requests
				final String timestamp = new Timestamp(System.currentTimeMillis() 
								+ TimeZone.getTimeZone("EST").getRawOffset()).toString();
				Thread t = new Thread(new Runnable() {
					public void run() {
						//TODO: Write code for GET operation here.
                        //Each GET operation is handled in a different thread.
                        //Highly recommended that you make use of helper functions.

						if (storageType.equals("replication")) {
							// Replication Mode
							req.response().end(replicationGET(key, timestamp, loc));

						} else if (storageType.equals("sharding")) {
							// Sharding mode
							req.response().end(shardingGET(key, loc, timestamp));
							
						} else {
							//Default response = 0
							req.response().end("0");
						}
					}
				});
				t.start();
			}
		});

		routeMatcher.get("/storage", new Handler<HttpServerRequest>() {
                        @Override
                        public void handle(final HttpServerRequest req) {
                                MultiMap map = req.params();
                                storageType = map.get("storage");
                                //This endpoint will be used by the auto-grader to set the 
								//consistency type that your key-value store has to support.
                                //You can initialize/re-initialize the required data structures here
                                req.response().end();
                        }
                });

		routeMatcher.noMatch(new Handler<HttpServerRequest>() {
			@Override
			public void handle(final HttpServerRequest req) {
				req.response().putHeader("Content-Type", "text/html");
				String response = "Not found.";
				req.response().putHeader("Content-Length",
						String.valueOf(response.length()));
				req.response().end(response);
				req.response().close();
			}
		});
		server.requestHandler(routeMatcher);
		server.listen(8080);
	}

	/*
	 * GET resource when doing sharding
	 */
	private String shardingGET(String key, String loc, String timestamp) {

		System.out.println("GET key: " + key);
		// Compute hashCode
		int hashCode = hashCode(key);

		// Wrong location
		if (!loc.equals("" + hashCode)) {
			return "0";
		}

		// Add task to queue
		String res = null;
		if (!queueMap.containsKey(key)) {
			PriorityQueue<String> pq = new PriorityQueue<String>();
			pq.add(timestamp);
			queueMap.put(key, pq);
		} else {
			queueMap.get(key).add(timestamp);
		}

		// Judge top of queue
		// Wait for the quque
		PriorityQueue<String> queue = queueMap.get(key);
		synchronized (queue) {
			while (!queue.peek().equals(timestamp)) {
				// Sleep
				try {
					System.out.println("GET Waiting key: " + key);
					queue.wait();
					// Thread.sleep(SLEEP_INTEVAL);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			System.out.println("GET Begin Executing key: " + key);

			// Now this task's turn
			// lock.lock();
			try {
				switch (hashCode) {
					case 1:
						res = KeyValueLib.GET(dataCenter1, key);
						break;
					case 2:
						res = KeyValueLib.GET(dataCenter2, key);
						break;
					case 3:
						res = KeyValueLib.GET(dataCenter3, key);
						break;
				}
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				// Finished, remove the object
				queue.poll();
				queue.notifyAll();
				// lock.unlock();
			}
		}
		System.out.println("GET Finished key: " + key);
		return res;
	}

	/*
	 * PUT resource when doing sharding
	 */
	private boolean shardingPUT(String key, String value, String timestamp) {

		System.out.println("PUT key: " + key);
		
		// Compute hashCode
		int hashCode = hashCode(key);

		// Add task to queue
		if (!queueMap.containsKey(key)) {
			PriorityQueue<String> pq = new PriorityQueue<String>();
			pq.add(timestamp);
			queueMap.put(key, pq);
		} else {
			queueMap.get(key).add(timestamp);
		}

		// Judge top of queue
		// Wait for the quque
		PriorityQueue<String> queue = queueMap.get(key);
		synchronized (queue) {
			while (!queue.peek().equals(timestamp)) {
				// Sleep
				try {
					System.out.println("PUT Waiting key: " + key);
					queue.wait();
					// Thread.sleep(SLEEP_INTEVAL);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			System.out.println("PUT Begin Executing key: " + key);

			// Now this task's turn
			// lock.lock();
			try {
				// PUT operation
				// Use this to protect Atomicity
				return PUTOneResult(key, value, hashCode);

			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				// Finished, remove the object
				queue.poll();
				queue.notifyAll();
				// lock.unlock();
			}
		}
		System.out.println("PUT Finished key: " + key);
		return true;
	}

	/*
	 * PUT all result to protect Atomicity
	 */
	private boolean PUTOneResult(String key, String value, int hashCode) {

		try {
			switch (hashCode) {
				case 1:
					// PUT
					KeyValueLib.PUT(dataCenter1, key, value);    
					// Check it fails or not
					if (!KeyValueLib.GET(dataCenter1, key).equals(value)) {
						return false;
					}
					break;

				case 2:
					// PUT
					KeyValueLib.PUT(dataCenter2, key, value);    
					// Check it fails or not
					if (!KeyValueLib.GET(dataCenter2, key).equals(value)) {
						return false;
					}
					break;

				case 3:
					// PUT
					KeyValueLib.PUT(dataCenter3, key, value);
					// Check it fails or not
					if (!KeyValueLib.GET(dataCenter3, key).equals(value)) {
						return false;
					}
					break;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		return true;
	}

	/*
	 * PUT resource when doing replication
	 */
	private boolean replicationPUT(String key, String value, String timestamp) {

		System.out.println("PUT key: " + key);
		// Add task to queue
		if (!queueMap.containsKey(key)) {
			PriorityQueue<String> pq = new PriorityQueue<String>();
			pq.add(timestamp);
			queueMap.put(key, pq);
		} else {
			queueMap.get(key).add(timestamp);
		}

		// Judge top of queue
		// Wait for the quque
		PriorityQueue<String> queue = queueMap.get(key);
		synchronized (queue) {
			while (!queue.peek().equals(timestamp)) {
				// Sleep
				try {
					System.out.println("PUT Waiting key: " + key);
					queue.wait();
					// Thread.sleep(SLEEP_INTEVAL);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			System.out.println("PUT Begin Executing key: " + key);
			// Now this task's turn
			// lock.lock();
			try {
				// PUT operation
				PUTAllResult(key, value);

				// Use this to protect Atomicity
				String[] after = GETAllResult(key, value);

				// Judge whether fail or not
				for (int i = 0; i < 3; i++) {
					if (!after[i].equals(value)) {
						System.out.println("PUT Inconsistency key: " + key);
						return false;
					}
				}

			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				// Finished, remove the object
				queue.poll();
				queue.notifyAll();
				// lock.unlock();
			}
		}
		System.out.println("PUT Finished key: " + key);
		return true;
	}

	/*
	 * PUT all result to protect Atomicity
	 */
	private void PUTAllResult(String key, String value) {

		Thread thread1 = new Thread(new Runnable() {
			public void run() {
				try {
					KeyValueLib.PUT(dataCenter1, key, value);    
				} catch(Exception e1) {
					e1.printStackTrace();
				}
			}
		});
		Thread thread2 = new Thread(new Runnable() {
			public void run() {
				try {
					KeyValueLib.PUT(dataCenter2, key, value);    
				} catch(Exception e2) {
					e2.printStackTrace();
				}
			}
		});
		Thread thread3 = new Thread(new Runnable() {
			public void run() {
				try {
					KeyValueLib.PUT(dataCenter3, key, value);    
				} catch(Exception e3) {
					e3.printStackTrace();
				}
			}
		});

		// Start threads
		thread1.start();
		thread2.start();
		thread3.start();

		// Judge threads finished or not
		while (thread1.isAlive() || thread2.isAlive() || thread3.isAlive()) {
			try {
				Thread.sleep(SLEEP_INTEVAL);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	/*
	 * GET all result to protect Atomicity
	 */
	private String[] GETAllResult(String key, String loc) {

		String[] res = new String[3];
		Thread thread1 = new Thread(new Runnable() {
			public void run() {
				try {
					res[0] = KeyValueLib.GET(dataCenter1, key);
				} catch(Exception e1) {
					e1.printStackTrace();
				}
			}
		});
		Thread thread2 = new Thread(new Runnable() {
			public void run() {
				try {
					res[1] = KeyValueLib.GET(dataCenter1, key); 
				} catch(Exception e2) {
					e2.printStackTrace();
				}
			}
		});
		Thread thread3 = new Thread(new Runnable() {
			public void run() {
				try {
					res[2] = KeyValueLib.GET(dataCenter1, key);    
				} catch(Exception e3) {
					e3.printStackTrace();
				}
			}
		});

		// Start threads
		thread1.start();
		thread2.start();
		thread3.start();

		// Judge threads finished or not
		while (thread1.isAlive() || thread2.isAlive() || thread3.isAlive()) {
			try {
				Thread.sleep(SLEEP_INTEVAL);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		return res;
	}

	/*
	 * GET resource when doing replication
	 */
	private String replicationGET(String key, String timestamp, String loc) {

		System.out.println("GET key: " + key);

		// Add task to queue
		String res = null;
		if (!queueMap.containsKey(key)) {
			PriorityQueue<String> pq = new PriorityQueue<String>();
			pq.add(timestamp);
			queueMap.put(key, pq);
		} else {
			queueMap.get(key).add(timestamp);
		}

		// Judge top of queue
		// Wait for the quque
		PriorityQueue<String> queue = queueMap.get(key);
		synchronized (queue) {
			while (!queue.peek().equals(timestamp)) {
				// Sleep
				try {
					System.out.println("GET Waiting key: " + key);
					queue.wait();
					// Thread.sleep(SLEEP_INTEVAL);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			System.out.println("GET Begin Executing key: " + key);

			// Now this task's turn
			// lock.lock();
			try {
				switch (loc) {
					case "1":
						res = KeyValueLib.GET(dataCenter1, key);
						break;
					case "2":
						res = KeyValueLib.GET(dataCenter2, key);
						break;
					case "3":
						res = KeyValueLib.GET(dataCenter3, key);
						break;
				}
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				// Finished, remove the object
				queue.poll();
				queue.notifyAll();
				// lock.unlock();
			}
		}
		System.out.println("GET Finished key: " + key);
		return res;
	}

	/*
	 * Compute HashCode of a input String
	 */
	private int hashCode(String key) {

		int result = 0;
		if (hashing.containsKey(key)) {
			// If has already computed this hashcode
			result = hashing.get(key);
		} else {
			// If this is a new key, compute it and then add it to the map
			for (int i = 0; i < key.length(); i++) {
				int temp = key.charAt(i) - 'a';
				switch (i % 3) {
					case 0:
						result += temp;
						break;
					case 1:
						result -= temp;
						break;
					case 2:
						result -= temp;
						break;
				}
			}
			// Ensure non-negative and a1 b2 c3
			result = ((result % 3) + 3) % 3 + 1;
			hashing.put(key, result);
		}

		System.out.println("hashCode: " + result);
		return result;
	}
}
